---
title: "Developer Quick Start"
description: "Datafruit is a pythonic data transformation framework that brings declarative configuration to your data pipelines."
---

## âœ… Installation

```bash
pip install datafruit
```

## Step 1: Define Base Tables

Create a simple schema using Python classes. This file isnâ€™t executedâ€”just declarative config.

```python
# models.py
import datafruit as dft
from typing import Optional

class users(dft.Table):
    id: Optional[int] = dft.Field(primary_key=True)
    name: str
    email: str
    is_active: bool = True

class orders(dft.Table):
    id: Optional[int] = dft.Field(primary_key=True)
    user_id: int = dft.Field(foreign_key="users.id")
    amount: float
    status: str = "pending"

databases = {
    "warehouse": dft.PostgresDB("postgresql://localhost/warehouse", tables=[users, orders])
}

dft.export(databases=databases)
```

```bash
$ dft plan

Planning schema changes...
Target: warehouse

Datafruit will perform the following actions:

+ Table: orders
â”‚ + Add column id (INTEGER)
â”‚ + Add column user_id (INTEGER)
â”‚ + Add column amount (FLOAT)
â”‚ + Add column status (VARCHAR)

+ Table: users
â”‚ + Add column id (INTEGER)
â”‚ + Add column name (VARCHAR)
â”‚ + Add column email (VARCHAR)
â”‚ + Add column is_active (BOOLEAN)

âœ“ Plan saved to .dft/plan.json
Run 'dft apply' to apply these changes.
```

```bash
$ dft apply

Applying schema changes...
âœ“ Successfully applied changes to 'warehouse'
```

---

## Step 2: Add Views and Models with `@query`

Use `@query(db=..., type="")` to define transformations:

| materialization type | meaning                             |
| -------------------- | ----------------------------------- |
| view                 | Stored as a SQL view                |
| table                | Materialized and written to a table |

```python
# models.py (continued)
db = databases["warehouse"]

@dft.query(db=db, type="view")
def active_users():
    return f"SELECT * FROM {users} WHERE is_active = true"

@dft.query(db=db, type="view")
def completed_orders():
    return f"""
    SELECT * FROM {orders}
    WHERE status = 'completed' AND amount > 0
    """

@dft.query(db=db, type="table")
def user_stats():
    return f"""
    SELECT 
        u.id AS user_id,
        COUNT(o.id) AS total_orders,
        SUM(o.amount) AS total_spent,
        AVG(o.amount) AS avg_order_value
    FROM {active_users} u
    LEFT JOIN {completed_orders} o ON u.id = o.user_id
    GROUP BY u.id
    """
```

And define the table schema for `user_stats`:

```python
class user_stats(dft.Table):
    user_id: int = dft.Field(primary_key=True)
    total_orders: int
    total_spent: float
    avg_order_value: float
```

---

## Step 3: Plan, Apply, Run

```bash
$ dft plan

Planning schema changes...
Target: warehouse

+ View: active_users
+ View: completed_orders
+ Table: user_stats
â”‚ + Add column user_id (INTEGER)
â”‚ + Add column total_orders (INTEGER)
â”‚ + Add column total_spent (FLOAT)
â”‚ + Add column avg_order_value (FLOAT)

âœ“ Plan saved to .dft/plan.json
```

```bash
$ dft apply

Applying schema changes...
âœ“ Created views: active_users, completed_orders
âœ“ Created table: user_stats
âœ“ Schema synced
```

```bash
$ dft run user_stats

â†’ Executing DAG:
   â€¢ active_users (view)
   â€¢ completed_orders (view)
   â€¢ user_stats (table)

âœ“ user_stats completed (1,247 rows)
âœ“ Data written to table: user_stats
```

---

## ğŸ§  Auto-Suggest Missing Schema

If you forget the `user_stats` class:

```bash
$ dft plan

âœ“ Computation graph valid

âš ï¸ Table 'user_stats' is declared as persistent, but has no schema defined.

Suggested schema:

class user_stats(dft.Table):
    user_id: int = dft.Field(primary_key=True)
    total_orders: int
    total_spent: float
    avg_order_value: float

Add this to your models and re-run:
  dft plan
  dft apply
```

---

## ğŸ›‘ Safe by Default: Detecting Breakage

If you rename a column in `users`:

```python
class users(dft.Table):
    id: Optional[int] = dft.Field(primary_key=True)
    name: str
    email_address: str  # renamed from 'email'
    is_active: bool = True
```

```bash
$ dft plan

~ Table: users
â”‚ ~ Rename: email â†’ email_address

BREAKING CHANGE DETECTED:

Ã— View 'active_users' references users.email
Ã— Query 'user_stats' depends on active_users

Fix downstream queries before applying.
```